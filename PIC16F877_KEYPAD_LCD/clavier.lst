CCS PCM C Compiler, Version 4.062, 41466               06-mai-11 10:07

               Filename: \\TgeSrv1\Élèves_Dossiers\echaa013\Bureau\lab2\clavier.lst

               ROM used: 1549 words (19%)
                         Largest free fragment is 2048
               RAM used: 24 (7%) at main() level
                         52 (14%) worst case
               Stack:    6 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   5AF
0003:  NOP
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /*****************************************************************************/ 
.................... /*                                                                           */ 
.................... /* Laboratoire de la serrure avec afficheur LCD et mémorisation de codes     */ 
.................... /*                                                                           */ 
.................... /* Nous utilisons un microcontrolleur PIC16F877                              */ 
.................... /*                                                                           */  
.................... /* Copyright Amélie Champagne et Dany Ferron                                 */ 
.................... /*****************************************************************************/ 
.................... /*                                                                           */  
.................... /* Travail 2                                                                 */ 
.................... /* Amélie et Dany                                                            */ 
.................... /* le 3 mai 2011                                                             */ 
.................... /*                                                                           */ 
.................... /*****************************************************************************/ 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #include <clavier.h> 
.................... #include <16F877.h> 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES XT                    	//Crystal osc <= 4mhz 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES BROWNOUT              	//Reset when brownout detected 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOWRT                 	//Program memory not write protected 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
....................  
.................... #use delay(clock=4000000) 
*
00BD:  MOVLW  45
00BE:  MOVWF  04
00BF:  BCF    03.7
00C0:  MOVF   00,W
00C1:  BTFSC  03.2
00C2:  GOTO   0D1
00C3:  MOVLW  01
00C4:  MOVWF  78
00C5:  CLRF   77
00C6:  DECFSZ 77,F
00C7:  GOTO   0C6
00C8:  DECFSZ 78,F
00C9:  GOTO   0C5
00CA:  MOVLW  4A
00CB:  MOVWF  77
00CC:  DECFSZ 77,F
00CD:  GOTO   0CC
00CE:  GOTO   0CF
00CF:  DECFSZ 00,F
00D0:  GOTO   0C3
00D1:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
.................... //Broches pour LCD. 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_RS_PIN      PIN_D1 
.................... #define LCD_RW_PIN      PIN_D2 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7 
.................... #define LCD_TYPE 2 
.................... //Pilote LCD. 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    //#locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf81 
....................    #else 
....................     #locate lcd = 6 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    //#locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #ifdef __pch__ 
....................     #locate lcd = 0xf83 
....................    #else 
....................     #locate lcd = 8 
....................    #endif 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... #ifndef lcd_type 
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
00DF:  MOVLW  F0
00E0:  BSF    03.5
00E1:  MOVWF  08
....................       lcd.rw = 1; 
00E2:  BCF    03.5
00E3:  BSF    08.2
....................       delay_cycles(1); 
00E4:  NOP
....................       lcd.enable = 1; 
00E5:  BSF    08.0
....................       delay_cycles(1); 
00E6:  NOP
....................       high = lcd.data; 
00E7:  MOVF   08,W
00E8:  SWAPF  08,W
00E9:  ANDLW  0F
00EA:  MOVWF  4C
....................       lcd.enable = 0; 
00EB:  BCF    08.0
....................       delay_cycles(1); 
00EC:  NOP
....................       lcd.enable = 1; 
00ED:  BSF    08.0
....................       delay_us(1); 
00EE:  NOP
....................       low = lcd.data; 
00EF:  MOVF   08,W
00F0:  SWAPF  08,W
00F1:  ANDLW  0F
00F2:  MOVWF  4B
....................       lcd.enable = 0; 
00F3:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
00F4:  MOVLW  00
00F5:  BSF    03.5
00F6:  MOVWF  08
....................       return( (high<<4) | low); 
00F7:  BCF    03.5
00F8:  SWAPF  4C,W
00F9:  MOVWF  77
00FA:  MOVLW  F0
00FB:  ANDWF  77,F
00FC:  MOVF   77,W
00FD:  IORWF  4B,W
00FE:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
00D2:  SWAPF  4C,W
00D3:  ANDLW  F0
00D4:  MOVWF  77
00D5:  MOVLW  0F
00D6:  ANDWF  08,W
00D7:  IORWF  77,W
00D8:  MOVWF  08
....................       delay_cycles(1); 
00D9:  NOP
....................       lcd.enable = 1; 
00DA:  BSF    08.0
....................       delay_us(2); 
00DB:  GOTO   0DC
....................       lcd.enable = 0; 
00DC:  BCF    08.0
.................... } 
00DD:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
00DE:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
00FF:  MOVF   78,W
0100:  MOVWF  4B
0101:  BTFSC  4B.7
0102:  GOTO   0DF
....................       lcd.rs = address; 
0103:  BTFSS  49.0
0104:  BCF    08.1
0105:  BTFSC  49.0
0106:  BSF    08.1
....................       delay_cycles(1); 
0107:  NOP
....................       lcd.rw = 0; 
0108:  BCF    08.2
....................       delay_cycles(1); 
0109:  NOP
....................       lcd.enable = 0; 
010A:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
010B:  SWAPF  4A,W
010C:  MOVWF  4B
010D:  MOVLW  0F
010E:  ANDWF  4B,F
010F:  MOVF   4B,W
0110:  MOVWF  4C
0111:  CALL   0D2
....................       lcd_send_nibble(n & 0xf); 
0112:  MOVF   4A,W
0113:  ANDLW  0F
0114:  MOVWF  4B
0115:  MOVWF  4C
0116:  CALL   0D2
.................... } 
0117:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
0118:  MOVLW  00
0119:  BSF    03.5
011A:  MOVWF  08
....................     lcd.rs = 0; 
011B:  BCF    03.5
011C:  BCF    08.1
....................     lcd.rw = 0; 
011D:  BCF    08.2
....................     lcd.enable = 0; 
011E:  BCF    08.0
....................     delay_ms(15); 
011F:  MOVLW  0F
0120:  MOVWF  45
0121:  CALL   0BD
....................     for(i=1;i<=3;++i) { 
0122:  MOVLW  01
0123:  MOVWF  31
0124:  MOVF   31,W
0125:  SUBLW  03
0126:  BTFSS  03.0
0127:  GOTO   130
....................        lcd_send_nibble(3); 
0128:  MOVLW  03
0129:  MOVWF  4C
012A:  CALL   0D2
....................        delay_ms(5); 
012B:  MOVLW  05
012C:  MOVWF  45
012D:  CALL   0BD
....................     } 
012E:  INCF   31,F
012F:  GOTO   124
....................     lcd_send_nibble(2); 
0130:  MOVLW  02
0131:  MOVWF  4C
0132:  CALL   0D2
....................     for(i=0;i<=3;++i) 
0133:  CLRF   31
0134:  MOVF   31,W
0135:  SUBLW  03
0136:  BTFSS  03.0
0137:  GOTO   141
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
0138:  MOVF   31,W
0139:  CALL   004
013A:  MOVWF  32
013B:  CLRF   49
013C:  MOVF   32,W
013D:  MOVWF  4A
013E:  CALL   0DE
013F:  INCF   31,F
0140:  GOTO   134
.................... } 
0141:  BCF    0A.3
0142:  BCF    0A.4
0143:  GOTO   5CB (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
01CC:  DECFSZ 46,W
01CD:  GOTO   1CF
01CE:  GOTO   1D2
....................      address=lcd_line_two; 
01CF:  MOVLW  40
01D0:  MOVWF  47
....................    else 
01D1:  GOTO   1D3
....................      address=0; 
01D2:  CLRF   47
....................    address+=x-1; 
01D3:  MOVLW  01
01D4:  SUBWF  45,W
01D5:  ADDWF  47,F
....................    lcd_send_byte(0,0x80|address); 
01D6:  MOVF   47,W
01D7:  IORLW  80
01D8:  MOVWF  48
01D9:  CLRF   49
01DA:  MOVF   48,W
01DB:  MOVWF  4A
01DC:  CALL   0DE
.................... } 
01DD:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
01DE:  MOVF   44,W
01DF:  XORLW  0C
01E0:  BTFSC  03.2
01E1:  GOTO   1E9
01E2:  XORLW  06
01E3:  BTFSC  03.2
01E4:  GOTO   1F1
01E5:  XORLW  02
01E6:  BTFSC  03.2
01E7:  GOTO   1F7
01E8:  GOTO   1FC
....................      case '\f'   : lcd_send_byte(0,1); 
01E9:  CLRF   49
01EA:  MOVLW  01
01EB:  MOVWF  4A
01EC:  CALL   0DE
....................                    delay_ms(2); 
01ED:  MOVLW  02
01EE:  MOVWF  45
01EF:  CALL   0BD
....................                                            break; 
01F0:  GOTO   202
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
01F1:  MOVLW  01
01F2:  MOVWF  45
01F3:  MOVLW  02
01F4:  MOVWF  46
01F5:  CALL   1CC
01F6:  GOTO   202
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
01F7:  CLRF   49
01F8:  MOVLW  10
01F9:  MOVWF  4A
01FA:  CALL   0DE
01FB:  GOTO   202
....................      default     : lcd_send_byte(1,c);     break; 
01FC:  MOVLW  01
01FD:  MOVWF  49
01FE:  MOVF   44,W
01FF:  MOVWF  4A
0200:  CALL   0DE
0201:  GOTO   202
....................    } 
.................... } 
0202:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... //Ficher avec définitions. 
.................... #include <lcd_db666.h> 
....................  
.................... /*template for custom characters 
....................  
.................... lcd_send_byte(0,0x40);  
....................  
....................  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
.................... lcd_send_byte(1,0b00000); // | | | | | |  
....................  
....................  
....................  
....................  
....................  
.................... lcd_gotoxy(1,1);  
.................... lcd_send_byte(1,0);  
.................... */ 
....................  
.................... //Define write to CGRAM adress 
.................... #define WR_ADRESS_1  lcd_send_byte(0,0x40) //0 ASCII code 
.................... #define WR_ADRESS_2  lcd_send_byte(0,0x48) //1 ASCII code 
.................... #define WR_ADRESS_3  lcd_send_byte(0,0x50) //2 ASCII code 
.................... #define WR_ADRESS_4  lcd_send_byte(0,0x58) //3 ASCII code 
.................... #define WR_ADRESS_5  lcd_send_byte(0,0x60) //4 ASCII code 
.................... #define WR_ADRESS_6  lcd_send_byte(0,0x68) //5 ASCII code 
.................... #define WR_ADRESS_7  lcd_send_byte(0,0x70) //6 ASCII code 
.................... #define WR_ADRESS_8  lcd_send_byte(0,0x78) //7 ASCII code 
.................... /* 
.................... //Define print to lcd character from CGRAM adress 
.................... #define prnt_char_1 lcd_send_byte(1,0) 
.................... #define prnt_char_2 lcd_send_byte(1,1) 
.................... #define prnt_char_3 lcd_send_byte(1,2) 
.................... #define prnt_char_4 lcd_send_byte(1,3) 
.................... #define prnt_char_5 lcd_send_byte(1,4) 
.................... #define prnt_char_6 lcd_send_byte(1,5) 
.................... #define prnt_char_7 lcd_send_byte(1,6) 
.................... #define prnt_char_8 lcd_send_byte(1,7) 
....................  
.................... //table de fontions LCD 
.................... #define clear_lcd         0x01 // Clear Display 
.................... #define return_home       0x02 // Cursor to Home position 
.................... #define entry_mode            0x06 // Normal entry mode 
.................... #define entry_mode_rev        0x04 // Normal entry mode  -reverse direction 
.................... #define entry_mode_scroll 0x07 // - with shift 
.................... #define entry_mode_scroll_rev   0x05 // reverse direction 
....................   
.................... #define system_set_8_bit      0x38 // 8 bit data mode 2 line ( 5x7 font ) 
.................... #define system_set_4_bit      0x28 // 4 bit data mode 2 line ( 5x7 font ) 
.................... #define system_set_reset      0x30 // Reset code 
.................... #define display_on            0x0C // Display ON - 2 line mode 
.................... #define display_off       0x08 // Display off 
.................... #define set_dd_line1          0x80 // Line 1 position 1 
.................... #define set_dd_line2          0xC0 // Line 2 position 1 
.................... #define set_dd_ram            0x80 // Line 1 position 1 
.................... #define write_data            0x00 // With RS = 1 
.................... #define cursor_on         0x0E // Switch Cursor ON 
.................... #define cursor_off            0x0C // Switch Cursor OFF 
.................... #define cursor_blink_on   0x0F // Cursor plus blink 
.................... #define cursor_shift_right    0x14 // Move cursor right 
.................... #define cursor_shift_left 0x10 // Move cursor left 
.................... #define display_shift_right    0x1C // Scroll display right 
.................... #define display_shift_left    0x18 // Scroll display left 
.................... */ 
....................  
....................  
.................... void clr_display(void) 
.................... { 
.................... lcd_send_byte(0,1); 
*
01C7:  CLRF   49
01C8:  MOVLW  01
01C9:  MOVWF  4A
01CA:  CALL   0DE
.................... } 
01CB:  RETLW  00
....................  
.................... void lcd_scroll_right(void)  
.................... {  
.................... lcd_send_byte(0, 0x1E);  
.................... }  
....................  
....................  
.................... void lcd_scroll_left(void)  
.................... {  
.................... lcd_send_byte(0, 0x18);  
.................... } 
....................  
.................... void cursor_on(void)  
.................... {  
.................... lcd_send_byte(0, 0x0E);  
.................... } 
....................  
.................... void cursor_off(void)  
.................... {  
.................... lcd_send_byte(0, 0x0C);  
*
0339:  CLRF   49
033A:  MOVLW  0C
033B:  MOVWF  4A
033C:  CALL   0DE
.................... } 
033D:  RETLW  00
.................... void cursor_blink_on(void)  
.................... {  
.................... lcd_send_byte(0, 0x0F);  
*
02C4:  CLRF   49
02C5:  MOVLW  0F
02C6:  MOVWF  4A
02C7:  CALL   0DE
.................... } 
....................  
.................... void cursor_blink_off(void)  
.................... {  
.................... lcd_send_byte(0, 0x0D);  
.................... } 
....................  
.................... //scroll test template 
....................  
.................... /* 
.................... int8 i;  
....................  
.................... lcd_init(); 
.................... lcd_gotoxy(5,1); 
.................... lcd_putc("\f");  // Clear the LCD  
.................... delay_ms(100);     
....................  
....................  
.................... char ScrollTest[20]={"Hello to the world!"}; 
....................  
.................... printf(lcd_putc,"%s",ScrollTest); 
....................  
....................  
.................... while(1)  
....................   {  
....................    for(i = 0; i < 20; i++)  // Scroll for 20 chars  
....................       {  
....................        lcd_scroll_left();  
....................        delay_ms(300);   // This sets the scroll speed  
....................       }  
....................  
....................      
....................   }  
.................... */ 
....................  
.................... /* side scroll exemple 2 
....................  
.................... #include <16F877.H>  
.................... #fuses XT, NOWDT, NOPROTECT, BROWNOUT, PUT, NOLVP  
.................... #use delay(clock=4000000)  
....................  
.................... #include "flex_lcd.c"  
....................  
.................... void lcd_scroll_right(void)  
.................... {  
.................... lcd_send_byte(0, 0x1E);  
.................... }  
.................... //-------------------------  
.................... void lcd_scroll_left(void)  
.................... {  
.................... lcd_send_byte(0, 0x18);  
.................... }  
....................      
.................... //=======================  
.................... void main()  
.................... {  
.................... int8 i;  
....................  
.................... lcd_init();  
....................  
.................... lcd_putc("\f");  // Clear the LCD  
.................... delay_ms(100);     
....................  
.................... // The 16x2 LCD memory is 40 characters wide, so fill it  
.................... // up with data for two screens.  Each line below must  
.................... // contain 40 characters (excluding the newline).     
.................... lcd_putc("Hello to the        Side scrolling      \n");  
.................... lcd_putc("world.              demo.               ");  
....................  
.................... delay_ms(1000);  
....................  
.................... while(1)  
....................   {  
....................    for(i = 0; i < 20; i++)  // Scroll for 20 chars  
....................       {  
....................        lcd_scroll_left();  
....................        delay_ms(200);   // This sets the scroll speed  
....................       }  
....................  
....................    delay_ms(2000);   // Wait 2 seconds between scrolling  
....................                      // each screen.  
....................   }  
....................  
.................... } 
....................  
.................... */ 
....................  
.................... //Macro pour lecture du clavier. 
.................... #define INPUT_AB (((input_c()&0b00001111)*0x100)+input_b()) 
.................... //Définitions des touches. 
.................... #define KP_0 0b0000111111111110 
.................... #define KP_1 0b0000111111111101 
.................... #define KP_2 0b0000111111111011 
.................... #define KP_3 0b0000111111110111 
.................... #define KP_4 0b0000111111101111 
.................... #define KP_5 0b0000111111011111 
.................... #define KP_6 0b0000111110111111 
.................... #define KP_7 0b0000111101111111 
.................... #define KP_8 0b0000111011111111 
.................... #define KP_9 0b0000110111111111 
.................... #define KP_S 0b0000101111111111 
.................... #define KP_P 0b0000011111111111 
....................  
....................  
.................... //Buzzer 
.................... #define BUZZER PIN_A0 
.................... //LED. 
....................  
.................... #define LEDR PIN_A1 
.................... #define LEDV PIN_A2 
....................  
.................... #define STAR_KEY 10 
.................... #define POUND_KEY 11 
....................  
.................... #rom 0x2100={4,3,2,1} 
.................... #rom 0x2120={9,8,7,6} 
....................  
....................  
....................  
.................... //Mots de passe. 
.................... //long user_password=read_EEPROM(0x00); 
.................... //long code_admin=read_EEPROM(0x20); 
.................... long code_public; 
.................... long code_admin; 
.................... //Variables de lectures. 
.................... long code_validation=0,input_read=0,temp_passw; 
*
05C0:  BCF    03.5
05C1:  CLRF   24
05C2:  CLRF   25
05C3:  CLRF   26
05C4:  CLRF   27
.................... char try_msg=5; 
05C5:  MOVLW  05
05C6:  MOVWF  2A
.................... int8 x1,y1,x2,y2; 
....................  
.................... BOOLEAN alarm=FALSE; 
05C7:  BCF    2F.0
.................... //Addition des valeurs décalés et mettre en constante le code d'entré. 
.................... #define CODE_ENTRE ((val4*1000)+(val3*100)+(val2*10)+(val1*1)) 
.................... //Déclarations des sous-fonctions. 
.................... void unlock(); 
.................... long kp_read(); 
.................... void intrusion(); 
.................... void wrong_code(); 
.................... long read_combination(int8 x1,int8 y1,int8 x2,int8 y2); 
.................... void code_gestion(); 
.................... void kp_init(); 
....................  
.................... long read_from_EEPROM(int adr) 
.................... { 
.................... int8 i; 
.................... int8 val1,val2,val3,val4,val_temp; 
.................... for(i=0;i<4;i++) 
*
017E:  CLRF   32
017F:  MOVF   32,W
0180:  SUBLW  03
0181:  BTFSS  03.0
0182:  GOTO   19A
.................... { 
....................          
.................... val_temp=read_EEPROM(adr+i); 
0183:  MOVF   32,W
0184:  ADDWF  31,W
0185:  MOVWF  38
0186:  MOVF   38,W
0187:  BSF    03.6
0188:  MOVWF  0D
0189:  BSF    03.5
018A:  BCF    0C.7
018B:  BSF    0C.0
018C:  BCF    03.5
018D:  MOVF   0C,W
018E:  BCF    03.6
018F:  MOVWF  37
.................... val4=val3; 
0190:  MOVF   35,W
0191:  MOVWF  36
.................... val3=val2; 
0192:  MOVF   34,W
0193:  MOVWF  35
.................... val2=val1; 
0194:  MOVF   33,W
0195:  MOVWF  34
.................... val1=val_temp; 
0196:  MOVF   37,W
0197:  MOVWF  33
.................... } 
0198:  INCF   32,F
0199:  GOTO   17F
....................  
.................... val_temp=CODE_ENTRE; 
019A:  CLRF   48
019B:  MOVF   36,W
019C:  MOVWF  47
019D:  MOVLW  03
019E:  MOVWF  4A
019F:  MOVLW  E8
01A0:  MOVWF  49
01A1:  CALL   144
01A2:  MOVF   79,W
01A3:  MOVWF  39
01A4:  MOVF   78,W
01A5:  MOVWF  38
01A6:  MOVF   35,W
01A7:  MOVWF  3C
01A8:  MOVLW  64
01A9:  MOVWF  3D
01AA:  CALL   159
01AB:  MOVF   78,W
01AC:  ADDWF  38,W
01AD:  MOVWF  3A
01AE:  MOVF   39,W
01AF:  MOVWF  3B
01B0:  BTFSC  03.0
01B1:  INCF   3B,F
01B2:  MOVF   34,W
01B3:  MOVWF  3C
01B4:  MOVLW  0A
01B5:  MOVWF  3D
01B6:  CALL   159
01B7:  MOVF   78,W
01B8:  ADDWF  3A,W
01B9:  MOVWF  3C
01BA:  MOVF   3B,W
01BB:  MOVWF  3D
01BC:  BTFSC  03.0
01BD:  INCF   3D,F
01BE:  MOVF   33,W
01BF:  ADDWF  3C,W
01C0:  MOVWF  37
.................... return val_temp; 
01C1:  CLRF   7A
01C2:  MOVF   37,W
01C3:  MOVWF  78
01C4:  MOVF   7A,W
01C5:  MOVWF  79
.................... } 
01C6:  RETLW  00
....................  
.................... void write_to_EEPROM(int8 adr,int16 code) 
.................... { 
.................... int8 j; 
.................... int16 tableau[4]={0,0,0,0}; 
*
0363:  CLRF   38
0364:  CLRF   39
0365:  CLRF   3A
0366:  CLRF   3B
0367:  CLRF   3C
0368:  CLRF   3D
0369:  CLRF   3E
036A:  CLRF   3F
....................  
....................  
....................  
.................... for(j=1;j<=4;j++) 
036B:  MOVLW  01
036C:  MOVWF  37
036D:  MOVF   37,W
036E:  SUBLW  04
036F:  BTFSS  03.0
0370:  GOTO   391
.................... { 
....................  
....................  
.................... tableau[j]=code/(10); 
0371:  BCF    03.0
0372:  RLF    37,W
0373:  ADDLW  38
0374:  MOVWF  04
0375:  BCF    03.7
0376:  MOVF   36,W
0377:  MOVWF  43
0378:  MOVF   35,W
0379:  MOVWF  42
037A:  CLRF   45
037B:  MOVLW  0A
037C:  MOVWF  44
037D:  CALL   33E
037E:  MOVF   78,W
037F:  MOVWF  00
0380:  INCF   04,F
0381:  MOVF   79,W
0382:  MOVWF  00
.................... code=code%10; 
0383:  MOVF   36,W
0384:  MOVWF  43
0385:  MOVF   35,W
0386:  MOVWF  42
0387:  CLRF   45
0388:  MOVLW  0A
0389:  MOVWF  44
038A:  CALL   33E
038B:  MOVF   77,W
038C:  MOVWF  35
038D:  MOVF   7A,W
038E:  MOVWF  36
....................  
.................... } 
038F:  INCF   37,F
0390:  GOTO   36D
....................  
.................... for(j=0;j<=3;j++) 
0391:  CLRF   37
0392:  MOVF   37,W
0393:  SUBLW  03
0394:  BTFSS  03.0
0395:  GOTO   3C3
.................... { 
....................  
.................... write_EEPROM((adr+j),(tableau[j])); 
0396:  MOVF   37,W
0397:  ADDWF  34,W
0398:  MOVWF  40
0399:  BCF    03.0
039A:  RLF    37,W
039B:  ADDLW  38
039C:  MOVWF  04
039D:  BCF    03.7
039E:  INCF   04,F
039F:  MOVF   00,W
03A0:  MOVWF  42
03A1:  DECF   04,F
03A2:  MOVF   00,W
03A3:  MOVWF  41
03A4:  MOVF   40,W
03A5:  BSF    03.6
03A6:  MOVWF  0D
03A7:  BCF    03.6
03A8:  MOVF   41,W
03A9:  BSF    03.6
03AA:  MOVWF  0C
03AB:  BSF    03.5
03AC:  BCF    0C.7
03AD:  BSF    0C.2
03AE:  BCF    03.5
03AF:  BCF    03.6
03B0:  MOVF   0B,W
03B1:  MOVWF  77
03B2:  BCF    0B.7
03B3:  BSF    03.5
03B4:  BSF    03.6
03B5:  MOVLW  55
03B6:  MOVWF  0D
03B7:  MOVLW  AA
03B8:  MOVWF  0D
03B9:  BSF    0C.1
03BA:  BTFSC  0C.1
03BB:  GOTO   3BA
03BC:  BCF    0C.2
03BD:  MOVF   77,W
03BE:  BCF    03.5
03BF:  BCF    03.6
03C0:  IORWF  0B,F
....................  
.................... } 
03C1:  INCF   37,F
03C2:  GOTO   392
.................... } 
03C3:  RETLW  00
....................  
.................... //Boucle principale. 
.................... void main()  
.................... { 
*
05AF:  CLRF   04
05B0:  BCF    03.7
05B1:  MOVLW  1F
05B2:  ANDWF  03,F
05B3:  MOVLW  19
05B4:  BSF    03.5
05B5:  MOVWF  19
05B6:  MOVLW  A6
05B7:  MOVWF  18
05B8:  MOVLW  90
05B9:  BCF    03.5
05BA:  MOVWF  18
05BB:  BSF    03.5
05BC:  BSF    1F.0
05BD:  BSF    1F.1
05BE:  BSF    1F.2
05BF:  BCF    1F.3
....................    lcd_init(); 
*
05CA:  GOTO   118
....................    code_admin=read_from_EEPROM(0x20); 
05CB:  MOVLW  20
05CC:  MOVWF  31
05CD:  CALL   17E
05CE:  MOVF   79,W
05CF:  MOVWF  23
05D0:  MOVF   78,W
05D1:  MOVWF  22
....................        
....................      code_public=read_from_EEPROM(0x00); 
05D2:  CLRF   31
05D3:  CALL   17E
05D4:  MOVF   79,W
05D5:  MOVWF  21
05D6:  MOVF   78,W
05D7:  MOVWF  20
....................       
....................    do 
....................    { 
....................       clr_display(); 
05D8:  CALL   1C7
....................        
....................       code_validation=read_combination(3,1,8,2);//Mettre la valeur retourné dans une variable 
05D9:  MOVLW  03
05DA:  MOVWF  34
05DB:  MOVLW  01
05DC:  MOVWF  35
05DD:  MOVLW  08
05DE:  MOVWF  36
05DF:  MOVLW  02
05E0:  MOVWF  37
05E1:  CALL   2A7
05E2:  MOVF   79,W
05E3:  MOVWF  25
05E4:  MOVF   78,W
05E5:  MOVWF  24
....................       //Si code validation est égale au mot de passe utilisateur ou administrateur 
....................       
....................       //if(code_validation==code_admin)code_gestion(); 
....................       if((code_validation==code_admin)&&(alarm==FALSE))code_gestion(); 
05E6:  MOVF   22,W
05E7:  SUBWF  24,W
05E8:  BTFSS  03.2
05E9:  GOTO   5F0
05EA:  MOVF   23,W
05EB:  SUBWF  25,W
05EC:  BTFSS  03.2
05ED:  GOTO   5F0
05EE:  BTFSS  2F.0
05EF:  GOTO   3C4
....................       else 
....................       { 
....................          if(code_validation==code_public) 
05F0:  MOVF   20,W
05F1:  SUBWF  24,W
05F2:  BTFSS  03.2
05F3:  GOTO   5FC
05F4:  MOVF   21,W
05F5:  SUBWF  25,W
05F6:  BTFSS  03.2
05F7:  GOTO   5FC
....................          { 
....................             unlock();//Appel de la fonction débarrer. 
05F8:  GOTO   43D
....................             try_msg=5; 
05F9:  MOVLW  05
05FA:  MOVWF  2A
....................          } 
....................          else 
05FB:  GOTO   60B
....................          { 
....................              
....................             wrong_code(); 
05FC:  GOTO   4D2
....................              
....................              
....................             if(try_msg==0) 
05FD:  MOVF   2A,F
05FE:  BTFSS  03.2
05FF:  GOTO   60B
....................             { 
....................                intrusion();//Appel de la fonction intrusion. 
0600:  GOTO   55F
....................                //Le code utilisateur est maintenant égale au code administrateur. 
....................                temp_passw=code_public; 
0601:  MOVF   21,W
0602:  MOVWF  29
0603:  MOVF   20,W
0604:  MOVWF  28
....................                code_public=code_admin; 
0605:  MOVF   23,W
0606:  MOVWF  21
0607:  MOVF   22,W
0608:  MOVWF  20
....................                try_msg=255; 
0609:  MOVLW  FF
060A:  MOVWF  2A
....................             } 
....................          } 
....................       } 
....................        
....................    } 
....................    while(TRUE);//Fin de la boucle infinie. 
.................... } 
060B:  GOTO   5D8
....................    //Fonction débarre. 
....................    void unlock() 
....................    { 
060C:  SLEEP
....................       char buzz_led_loop,door_opening,door_closing;//Variables locales. 
....................        
....................       alarm=FALSE; 
*
043D:  BCF    2F.0
....................       clr_display(); 
043E:  CALL   1C7
....................       cursor_off(); 
043F:  CALL   339
....................       lcd_gotoxy(5,1); 
0440:  MOVLW  05
0441:  MOVWF  45
0442:  MOVLW  01
0443:  MOVWF  46
0444:  CALL   1CC
....................        
....................       lcd_putc("Door Unlocked"); 
0445:  CLRF   34
0446:  MOVF   34,W
0447:  CALL   00C
0448:  IORLW  00
0449:  BTFSC  03.2
044A:  GOTO   44F
044B:  INCF   34,F
044C:  MOVWF  44
044D:  CALL   1DE
044E:  GOTO   446
....................        
....................       if(code_validation==code_admin) 
044F:  MOVF   22,W
0450:  SUBWF  24,W
0451:  BTFSS  03.2
0452:  GOTO   45B
0453:  MOVF   23,W
0454:  SUBWF  25,W
0455:  BTFSS  03.2
0456:  GOTO   45B
....................          { 
....................             code_public=temp_passw; 
0457:  MOVF   29,W
0458:  MOVWF  21
0459:  MOVF   28,W
045A:  MOVWF  20
....................          } 
....................           
....................      // user_password=temp_passw; 
....................     //  code_validation=user_password;//Code validation est égale au code utilisateur. 
....................       //Boucle indication sonore pour indiquer que la porte est ouverte. 
....................       for(buzz_led_loop=0;buzz_led_loop<4;buzz_led_loop++) 
045B:  CLRF   31
045C:  MOVF   31,W
045D:  SUBLW  03
045E:  BTFSS  03.0
045F:  GOTO   478
....................       { 
....................          delay_ms(50); 
0460:  MOVLW  32
0461:  MOVWF  45
0462:  CALL   0BD
....................          output_high(BUZZER); 
0463:  BSF    03.5
0464:  BCF    05.0
0465:  BCF    03.5
0466:  BSF    05.0
....................          output_low(LEDR); 
0467:  BSF    03.5
0468:  BCF    05.1
0469:  BCF    03.5
046A:  BCF    05.1
....................          delay_ms(100); 
046B:  MOVLW  64
046C:  MOVWF  45
046D:  CALL   0BD
....................          output_low(BUZZER); 
046E:  BSF    03.5
046F:  BCF    05.0
0470:  BCF    03.5
0471:  BCF    05.0
....................          output_high(LEDR); 
0472:  BSF    03.5
0473:  BCF    05.1
0474:  BCF    03.5
0475:  BSF    05.1
....................       } 
0476:  INCF   31,F
0477:  GOTO   45C
....................       output_low(LEDR); 
0478:  BSF    03.5
0479:  BCF    05.1
047A:  BCF    03.5
047B:  BCF    05.1
....................       //Boucle indicateur lumineux pour indiquer que la porte est ouverte. 
....................       for(door_opening=0;door_opening<10;door_opening++) 
047C:  CLRF   32
047D:  MOVF   32,W
047E:  SUBLW  09
047F:  BTFSS  03.0
0480:  GOTO   499
....................       { 
....................          output_low(LEDV); 
0481:  BSF    03.5
0482:  BCF    05.2
0483:  BCF    03.5
0484:  BCF    05.2
....................          delay_ms(500); 
0485:  MOVLW  02
0486:  MOVWF  34
0487:  MOVLW  FA
0488:  MOVWF  45
0489:  CALL   0BD
048A:  DECFSZ 34,F
048B:  GOTO   487
....................          output_high(LEDV); 
048C:  BSF    03.5
048D:  BCF    05.2
048E:  BCF    03.5
048F:  BSF    05.2
....................          delay_ms(500); 
0490:  MOVLW  02
0491:  MOVWF  34
0492:  MOVLW  FA
0493:  MOVWF  45
0494:  CALL   0BD
0495:  DECFSZ 34,F
0496:  GOTO   492
....................       } 
0497:  INCF   32,F
0498:  GOTO   47D
....................       //Indicateur sonore pour indiquer que la porte est barrée. 
....................       for(door_closing=0;door_closing<2;door_closing++) 
0499:  CLRF   33
049A:  MOVF   33,W
049B:  SUBLW  01
049C:  BTFSS  03.0
049D:  GOTO   4B6
....................       { 
....................          delay_ms(50); 
049E:  MOVLW  32
049F:  MOVWF  45
04A0:  CALL   0BD
....................          output_high(BUZZER); 
04A1:  BSF    03.5
04A2:  BCF    05.0
04A3:  BCF    03.5
04A4:  BSF    05.0
....................          output_low(LEDV); 
04A5:  BSF    03.5
04A6:  BCF    05.2
04A7:  BCF    03.5
04A8:  BCF    05.2
....................          delay_ms(100); 
04A9:  MOVLW  64
04AA:  MOVWF  45
04AB:  CALL   0BD
....................          output_low(BUZZER); 
04AC:  BSF    03.5
04AD:  BCF    05.0
04AE:  BCF    03.5
04AF:  BCF    05.0
....................          output_high(LEDV); 
04B0:  BSF    03.5
04B1:  BCF    05.2
04B2:  BCF    03.5
04B3:  BSF    05.2
....................       } 
04B4:  INCF   33,F
04B5:  GOTO   49A
....................       output_low(LEDV);//Remettre l'indicateur lumineux à off. 
04B6:  BSF    03.5
04B7:  BCF    05.2
04B8:  BCF    03.5
04B9:  BCF    05.2
....................    } 
04BA:  BCF    0A.3
04BB:  BCF    0A.4
04BC:  GOTO   5F9 (RETURN)
....................     
....................    //Fonction lecture de clavier. 
....................    long kp_read() 
....................    { 
....................        
....................       long temp=15;//Variable de lecture de touche temporaire. 
*
0203:  MOVLW  0F
0204:  MOVWF  43
0205:  CLRF   44
....................       //Si une des touches est appuyée on la met en banque. 
....................       do 
....................       { 
....................           
....................          input_read=INPUT_AB;//Mettre en variable la touche entrée. 
0206:  MOVLW  FF
0207:  MOVWF  30
0208:  BSF    03.5
0209:  MOVWF  07
020A:  BCF    03.5
020B:  MOVF   07,W
020C:  ANDLW  0F
020D:  MOVWF  48
020E:  CLRF   47
020F:  MOVLW  FF
0210:  BSF    03.5
0211:  MOVWF  06
0212:  BCF    03.5
0213:  MOVF   06,W
0214:  ADDWF  47,W
0215:  MOVWF  26
0216:  MOVF   48,W
0217:  MOVWF  27
0218:  BTFSC  03.0
0219:  INCF   27,F
*
05C8:  MOVLW  FF
05C9:  MOVWF  30
....................       } 
....................       while(input_read>=0xFFF);//Tant que que lecture clavier est plus grand que 4095. 
*
021A:  MOVF   27,W
021B:  SUBLW  0E
021C:  BTFSC  03.0
021D:  GOTO   225
021E:  XORLW  FF
021F:  BTFSS  03.2
0220:  GOTO   206
0221:  MOVF   26,W
0222:  SUBLW  FE
0223:  BTFSS  03.0
0224:  GOTO   206
....................        
....................       if(input_read==KP_0)temp=0; 
0225:  MOVF   26,W
0226:  SUBLW  FE
0227:  BTFSS  03.2
0228:  GOTO   22F
0229:  MOVF   27,W
022A:  SUBLW  0F
022B:  BTFSS  03.2
022C:  GOTO   22F
022D:  CLRF   44
022E:  CLRF   43
....................       if(input_read==KP_1)temp=1; 
022F:  MOVF   26,W
0230:  SUBLW  FD
0231:  BTFSS  03.2
0232:  GOTO   23A
0233:  MOVF   27,W
0234:  SUBLW  0F
0235:  BTFSS  03.2
0236:  GOTO   23A
0237:  CLRF   44
0238:  MOVLW  01
0239:  MOVWF  43
....................       if(input_read==KP_2)temp=2; 
023A:  MOVF   26,W
023B:  SUBLW  FB
023C:  BTFSS  03.2
023D:  GOTO   245
023E:  MOVF   27,W
023F:  SUBLW  0F
0240:  BTFSS  03.2
0241:  GOTO   245
0242:  CLRF   44
0243:  MOVLW  02
0244:  MOVWF  43
....................       if(input_read==KP_3)temp=3; 
0245:  MOVF   26,W
0246:  SUBLW  F7
0247:  BTFSS  03.2
0248:  GOTO   250
0249:  MOVF   27,W
024A:  SUBLW  0F
024B:  BTFSS  03.2
024C:  GOTO   250
024D:  CLRF   44
024E:  MOVLW  03
024F:  MOVWF  43
....................       if(input_read==KP_4)temp=4; 
0250:  MOVF   26,W
0251:  SUBLW  EF
0252:  BTFSS  03.2
0253:  GOTO   25B
0254:  MOVF   27,W
0255:  SUBLW  0F
0256:  BTFSS  03.2
0257:  GOTO   25B
0258:  CLRF   44
0259:  MOVLW  04
025A:  MOVWF  43
....................       if(input_read==KP_5)temp=5; 
025B:  MOVF   26,W
025C:  SUBLW  DF
025D:  BTFSS  03.2
025E:  GOTO   266
025F:  MOVF   27,W
0260:  SUBLW  0F
0261:  BTFSS  03.2
0262:  GOTO   266
0263:  CLRF   44
0264:  MOVLW  05
0265:  MOVWF  43
....................       if(input_read==KP_6)temp=6; 
0266:  MOVF   26,W
0267:  SUBLW  BF
0268:  BTFSS  03.2
0269:  GOTO   271
026A:  MOVF   27,W
026B:  SUBLW  0F
026C:  BTFSS  03.2
026D:  GOTO   271
026E:  CLRF   44
026F:  MOVLW  06
0270:  MOVWF  43
....................       if(input_read==KP_7)temp=7; 
0271:  MOVF   26,W
0272:  SUBLW  7F
0273:  BTFSS  03.2
0274:  GOTO   27C
0275:  MOVF   27,W
0276:  SUBLW  0F
0277:  BTFSS  03.2
0278:  GOTO   27C
0279:  CLRF   44
027A:  MOVLW  07
027B:  MOVWF  43
....................       if(input_read==KP_8)temp=8; 
027C:  INCFSZ 26,W
027D:  GOTO   285
027E:  MOVF   27,W
027F:  SUBLW  0E
0280:  BTFSS  03.2
0281:  GOTO   285
0282:  CLRF   44
0283:  MOVLW  08
0284:  MOVWF  43
....................       if(input_read==KP_9)temp=9; 
0285:  INCFSZ 26,W
0286:  GOTO   28E
0287:  MOVF   27,W
0288:  SUBLW  0D
0289:  BTFSS  03.2
028A:  GOTO   28E
028B:  CLRF   44
028C:  MOVLW  09
028D:  MOVWF  43
....................        
....................       if(input_read==KP_S)temp=STAR_KEY; 
028E:  INCFSZ 26,W
028F:  GOTO   297
0290:  MOVF   27,W
0291:  SUBLW  0B
0292:  BTFSS  03.2
0293:  GOTO   297
0294:  CLRF   44
0295:  MOVLW  0A
0296:  MOVWF  43
....................       if(input_read==KP_P)temp=POUND_KEY; 
0297:  INCFSZ 26,W
0298:  GOTO   2A0
0299:  MOVF   27,W
029A:  SUBLW  07
029B:  BTFSS  03.2
029C:  GOTO   2A0
029D:  CLRF   44
029E:  MOVLW  0B
029F:  MOVWF  43
....................        
....................       input_read=0;//Remettre la variable lecture à 0 
02A0:  CLRF   27
02A1:  CLRF   26
....................        
....................       return temp;//Retour de la touche vers le programme appelant. 
02A2:  MOVF   43,W
02A3:  MOVWF  78
02A4:  MOVF   44,W
02A5:  MOVWF  79
....................    } 
02A6:  RETLW  00
....................    //Fonction de l'alarme. 
....................    void intrusion() 
....................    { 
....................       char pulsar1;//Variable pour le compteur. 
....................        
....................       alarm=TRUE; 
*
055F:  BSF    2F.0
....................       clr_display(); 
0560:  CALL   1C7
....................       lcd_gotoxy(8,1); 
0561:  MOVLW  08
0562:  MOVWF  45
0563:  MOVLW  01
0564:  MOVWF  46
0565:  CALL   1CC
....................       lcd_putc("Alarm!"); 
0566:  CLRF   32
0567:  MOVF   32,W
0568:  CALL   01E
0569:  IORLW  00
056A:  BTFSC  03.2
056B:  GOTO   570
056C:  INCF   32,F
056D:  MOVWF  44
056E:  CALL   1DE
056F:  GOTO   567
....................       delay_ms(500); 
0570:  MOVLW  02
0571:  MOVWF  32
0572:  MOVLW  FA
0573:  MOVWF  45
0574:  CALL   0BD
0575:  DECFSZ 32,F
0576:  GOTO   572
....................       lcd_gotoxy(4,2); 
0577:  MOVLW  04
0578:  MOVWF  45
0579:  MOVLW  02
057A:  MOVWF  46
057B:  CALL   1CC
....................       lcd_putc("Admin required"); 
057C:  CLRF   32
057D:  MOVF   32,W
057E:  CALL   029
057F:  IORLW  00
0580:  BTFSC  03.2
0581:  GOTO   586
0582:  INCF   32,F
0583:  MOVWF  44
0584:  CALL   1DE
0585:  GOTO   57D
....................       output_high(BUZZER);//Niveau haut au buzzeur 
0586:  BSF    03.5
0587:  BCF    05.0
0588:  BCF    03.5
0589:  BSF    05.0
....................        
....................       for(pulsar1=1;pulsar1<=10;pulsar1++)//Compteur de zéro à dix. 
058A:  MOVLW  01
058B:  MOVWF  31
058C:  MOVF   31,W
058D:  SUBLW  0A
058E:  BTFSS  03.0
058F:  GOTO   5A8
....................       { 
....................          output_high(LEDR);//LED Rouge allumée. 
0590:  BSF    03.5
0591:  BCF    05.1
0592:  BCF    03.5
0593:  BSF    05.1
....................          delay_ms(500);//Pause de une demi seconde. 
0594:  MOVLW  02
0595:  MOVWF  32
0596:  MOVLW  FA
0597:  MOVWF  45
0598:  CALL   0BD
0599:  DECFSZ 32,F
059A:  GOTO   596
....................          output_low(LEDR);//LED Rouge éteinte. 
059B:  BSF    03.5
059C:  BCF    05.1
059D:  BCF    03.5
059E:  BCF    05.1
....................          delay_ms(500);//Pause de une demi seconde. 
059F:  MOVLW  02
05A0:  MOVWF  32
05A1:  MOVLW  FA
05A2:  MOVWF  45
05A3:  CALL   0BD
05A4:  DECFSZ 32,F
05A5:  GOTO   5A1
....................       } 
05A6:  INCF   31,F
05A7:  GOTO   58C
....................        
....................       output_low(BUZZER);//Niveau bas au buzzeur 
05A8:  BSF    03.5
05A9:  BCF    05.0
05AA:  BCF    03.5
05AB:  BCF    05.0
....................    } 
05AC:  BCF    0A.3
05AD:  BCF    0A.4
05AE:  GOTO   601 (RETURN)
....................    //Fonction lire combine qui retourne une variable. 
....................    long read_combination(int8 x1,int8 y1,int8 x2,int8 y2) 
....................    { 
....................        
....................       char count_input; 
....................       long val1=15,val2=15,val3=15,val4=15,touche;//Variables de lecture. 
*
02A7:  MOVLW  0F
02A8:  MOVWF  39
02A9:  CLRF   3A
02AA:  MOVWF  3B
02AB:  CLRF   3C
02AC:  MOVWF  3D
02AD:  CLRF   3E
02AE:  MOVWF  3F
02AF:  CLRF   40
....................       //Boucle à compteur permettant d'accumuler 4 touches entrées. 
....................       lcd_gotoxy(x1,y1); 
02B0:  MOVF   34,W
02B1:  MOVWF  45
02B2:  MOVF   35,W
02B3:  MOVWF  46
02B4:  CALL   1CC
....................       lcd_putc("Enter Code :"); 
02B5:  CLRF   43
02B6:  MOVF   43,W
02B7:  CALL   03C
02B8:  IORLW  00
02B9:  BTFSC  03.2
02BA:  GOTO   2BF
02BB:  INCF   43,F
02BC:  MOVWF  44
02BD:  CALL   1DE
02BE:  GOTO   2B6
....................       lcd_gotoxy(x2,y2); 
02BF:  MOVF   36,W
02C0:  MOVWF  45
02C1:  MOVF   37,W
02C2:  MOVWF  46
02C3:  CALL   1CC
....................       cursor_blink_on(); 
....................       for(count_input=1;count_input<=4;count_input++) 
*
02C8:  MOVLW  01
02C9:  MOVWF  38
02CA:  MOVF   38,W
02CB:  SUBLW  04
02CC:  BTFSS  03.0
02CD:  GOTO   2FA
....................       { 
....................  
....................          touche=kp_read();//Appel de la fonction lecture de clavier. 
02CE:  CALL   203
02CF:  MOVF   79,W
02D0:  MOVWF  42
02D1:  MOVF   78,W
02D2:  MOVWF  41
....................  
....................          //Décalage de la variable temporaire 4 fois. 
....................          val4=val3; 
02D3:  MOVF   3E,W
02D4:  MOVWF  40
02D5:  MOVF   3D,W
02D6:  MOVWF  3F
....................          val3=val2; 
02D7:  MOVF   3C,W
02D8:  MOVWF  3E
02D9:  MOVF   3B,W
02DA:  MOVWF  3D
....................          val2=val1; 
02DB:  MOVF   3A,W
02DC:  MOVWF  3C
02DD:  MOVF   39,W
02DE:  MOVWF  3B
....................          val1=touche; 
02DF:  MOVF   42,W
02E0:  MOVWF  3A
02E1:  MOVF   41,W
02E2:  MOVWF  39
....................           
....................          lcd_putc("*"); 
02E3:  CLRF   43
02E4:  MOVF   43,W
02E5:  CALL   04D
02E6:  IORLW  00
02E7:  BTFSC  03.2
02E8:  GOTO   2ED
02E9:  INCF   43,F
02EA:  MOVWF  44
02EB:  CALL   1DE
02EC:  GOTO   2E4
....................          output_high(BUZZER);//Activer le buzzeur. 
02ED:  BSF    03.5
02EE:  BCF    05.0
02EF:  BCF    03.5
02F0:  BSF    05.0
....................          delay_ms(250);//Pause de 250 ms. 
02F1:  MOVLW  FA
02F2:  MOVWF  45
02F3:  CALL   0BD
....................          output_low(BUZZER);//Sinon buzzeur est éteint. 
02F4:  BSF    03.5
02F5:  BCF    05.0
02F6:  BCF    03.5
02F7:  BCF    05.0
....................       } 
02F8:  INCF   38,F
02F9:  GOTO   2CA
....................       return CODE_ENTRE;//Retour du code entre vers le programme appelant. 
02FA:  MOVF   40,W
02FB:  MOVWF  48
02FC:  MOVF   3F,W
02FD:  MOVWF  47
02FE:  MOVLW  03
02FF:  MOVWF  4A
0300:  MOVLW  E8
0301:  MOVWF  49
0302:  CALL   144
0303:  MOVF   79,W
0304:  MOVWF  44
0305:  MOVF   78,W
0306:  MOVWF  43
0307:  MOVF   3E,W
0308:  MOVWF  48
0309:  MOVF   3D,W
030A:  MOVWF  47
030B:  CLRF   4A
030C:  MOVLW  64
030D:  MOVWF  49
030E:  CALL   144
030F:  MOVF   79,W
0310:  MOVWF  7A
0311:  MOVF   78,W
0312:  ADDWF  43,W
0313:  MOVWF  45
0314:  MOVF   44,W
0315:  MOVWF  46
0316:  MOVF   79,W
0317:  BTFSC  03.0
0318:  INCFSZ 79,W
0319:  ADDWF  46,F
031A:  MOVF   3C,W
031B:  MOVWF  48
031C:  MOVF   3B,W
031D:  MOVWF  47
031E:  CLRF   4A
031F:  MOVLW  0A
0320:  MOVWF  49
0321:  CALL   144
0322:  MOVF   79,W
0323:  MOVWF  7A
0324:  MOVF   78,W
0325:  ADDWF  45,W
0326:  MOVWF  47
0327:  MOVF   46,W
0328:  MOVWF  48
0329:  MOVF   79,W
032A:  BTFSC  03.0
032B:  INCFSZ 79,W
032C:  ADDWF  48,F
032D:  MOVF   39,W
032E:  ADDWF  47,W
032F:  MOVWF  78
0330:  MOVF   48,W
0331:  MOVWF  7A
0332:  MOVF   3A,W
0333:  BTFSC  03.0
0334:  INCFSZ 3A,W
0335:  ADDWF  7A,F
0336:  MOVF   7A,W
0337:  MOVWF  79
....................    } 
0338:  RETLW  00
....................    void wrong_code() 
....................    { 
....................       char pulsar2; 
....................        
....................       for(pulsar2=0;pulsar2<3;pulsar2++) 
*
04D2:  CLRF   31
04D3:  MOVF   31,W
04D4:  SUBLW  02
04D5:  BTFSS  03.0
04D6:  GOTO   4EF
....................       { 
....................          delay_ms(50); 
04D7:  MOVLW  32
04D8:  MOVWF  45
04D9:  CALL   0BD
....................          output_high(BUZZER); 
04DA:  BSF    03.5
04DB:  BCF    05.0
04DC:  BCF    03.5
04DD:  BSF    05.0
....................          output_low(LEDR); 
04DE:  BSF    03.5
04DF:  BCF    05.1
04E0:  BCF    03.5
04E1:  BCF    05.1
....................          delay_ms(100); 
04E2:  MOVLW  64
04E3:  MOVWF  45
04E4:  CALL   0BD
....................          output_low(BUZZER); 
04E5:  BSF    03.5
04E6:  BCF    05.0
04E7:  BCF    03.5
04E8:  BCF    05.0
....................          output_high(LEDR); 
04E9:  BSF    03.5
04EA:  BCF    05.1
04EB:  BCF    03.5
04EC:  BSF    05.1
....................       } 
04ED:  INCF   31,F
04EE:  GOTO   4D3
....................        
....................       try_msg--; 
04EF:  DECF   2A,F
....................       clr_display(); 
04F0:  CALL   1C7
....................       cursor_off(); 
04F1:  CALL   339
....................       lcd_gotoxy(6,1); 
04F2:  MOVLW  06
04F3:  MOVWF  45
04F4:  MOVLW  01
04F5:  MOVWF  46
04F6:  CALL   1CC
....................       lcd_putc("Wrong Code"); 
04F7:  CLRF   32
04F8:  MOVF   32,W
04F9:  CALL   053
04FA:  IORLW  00
04FB:  BTFSC  03.2
04FC:  GOTO   501
04FD:  INCF   32,F
04FE:  MOVWF  44
04FF:  CALL   1DE
0500:  GOTO   4F8
....................       delay_ms(1000); 
0501:  MOVLW  04
0502:  MOVWF  32
0503:  MOVLW  FA
0504:  MOVWF  45
0505:  CALL   0BD
0506:  DECFSZ 32,F
0507:  GOTO   503
....................       clr_display(); 
0508:  CALL   1C7
....................       lcd_gotoxy(6,2); 
0509:  MOVLW  06
050A:  MOVWF  45
050B:  MOVLW  02
050C:  MOVWF  46
050D:  CALL   1CC
....................       printf(lcd_putc,"Try Left %u",try_msg); 
050E:  CLRF   32
050F:  MOVF   32,W
0510:  CALL   062
0511:  INCF   32,F
0512:  MOVWF  77
0513:  MOVF   77,W
0514:  MOVWF  44
0515:  CALL   1DE
0516:  MOVLW  09
0517:  SUBWF  32,W
0518:  BTFSS  03.2
0519:  GOTO   50F
051A:  MOVF   2A,W
051B:  MOVWF  33
051C:  MOVLW  1B
051D:  MOVWF  34
....................       delay_ms(5000); 
*
0551:  MOVLW  14
0552:  MOVWF  32
0553:  MOVLW  FA
0554:  MOVWF  45
0555:  CALL   0BD
0556:  DECFSZ 32,F
0557:  GOTO   553
....................       output_low(LEDR); 
0558:  BSF    03.5
0559:  BCF    05.1
055A:  BCF    03.5
055B:  BCF    05.1
....................    } 
055C:  BCF    0A.3
055D:  BCF    0A.4
055E:  GOTO   5FD (RETURN)
....................  
....................    void code_gestion() 
....................    { 
....................       char response; 
....................       long temp_code; 
....................        
....................       clr_display(); 
*
03C4:  CALL   1C7
....................       cursor_off(); 
03C5:  CALL   339
....................       lcd_gotoxy(5,1); 
03C6:  MOVLW  05
03C7:  MOVWF  45
03C8:  MOVLW  01
03C9:  MOVWF  46
03CA:  CALL   1CC
....................       lcd_putc("Code Gestion"); 
03CB:  CLRF   34
03CC:  MOVF   34,W
03CD:  CALL   072
03CE:  IORLW  00
03CF:  BTFSC  03.2
03D0:  GOTO   3D5
03D1:  INCF   34,F
03D2:  MOVWF  44
03D3:  CALL   1DE
03D4:  GOTO   3CC
....................       lcd_gotoxy(3,2); 
03D5:  MOVLW  03
03D6:  MOVWF  45
03D7:  MOVLW  02
03D8:  MOVWF  46
03D9:  CALL   1CC
....................       lcd_putc("*=Admin #=Public"); 
03DA:  CLRF   34
03DB:  MOVF   34,W
03DC:  CALL   083
03DD:  IORLW  00
03DE:  BTFSC  03.2
03DF:  GOTO   3E4
03E0:  INCF   34,F
03E1:  MOVWF  44
03E2:  CALL   1DE
03E3:  GOTO   3DB
....................  
....................       response=kp_read(); 
03E4:  CALL   203
03E5:  MOVF   78,W
03E6:  MOVWF  31
....................  
....................       delay_ms(3000); 
03E7:  MOVLW  0C
03E8:  MOVWF  34
03E9:  MOVLW  FA
03EA:  MOVWF  45
03EB:  CALL   0BD
03EC:  DECFSZ 34,F
03ED:  GOTO   3E9
....................        
....................       clr_display(); 
03EE:  CALL   1C7
....................        
....................       if(response==STAR_KEY) 
03EF:  MOVF   31,W
03F0:  SUBLW  0A
03F1:  BTFSS  03.2
03F2:  GOTO   415
....................       { 
....................          lcd_gotoxy(3,1); 
03F3:  MOVLW  03
03F4:  MOVWF  45
03F5:  MOVLW  01
03F6:  MOVWF  46
03F7:  CALL   1CC
....................          lcd_putc("Code Superviseur");       
03F8:  CLRF   34
03F9:  MOVF   34,W
03FA:  CALL   098
03FB:  IORLW  00
03FC:  BTFSC  03.2
03FD:  GOTO   402
03FE:  INCF   34,F
03FF:  MOVWF  44
0400:  CALL   1DE
0401:  GOTO   3F9
....................          temp_code=read_combination(2,2,15,2); 
0402:  MOVLW  02
0403:  MOVWF  34
0404:  MOVWF  35
0405:  MOVLW  0F
0406:  MOVWF  36
0407:  MOVLW  02
0408:  MOVWF  37
0409:  CALL   2A7
040A:  MOVF   79,W
040B:  MOVWF  33
040C:  MOVF   78,W
040D:  MOVWF  32
....................          write_to_EEPROM(0x20,code_admin); 
040E:  MOVLW  20
040F:  MOVWF  34
0410:  MOVF   23,W
0411:  MOVWF  36
0412:  MOVF   22,W
0413:  MOVWF  35
0414:  CALL   363
....................       } 
....................        
....................       if(response==POUND_KEY) 
0415:  MOVF   31,W
0416:  SUBLW  0B
0417:  BTFSS  03.2
0418:  GOTO   43A
....................       { 
....................          lcd_gotoxy(5,1); 
0419:  MOVLW  05
041A:  MOVWF  45
041B:  MOVLW  01
041C:  MOVWF  46
041D:  CALL   1CC
....................          lcd_putc("Code Public"); 
041E:  CLRF   34
041F:  MOVF   34,W
0420:  CALL   0AD
0421:  IORLW  00
0422:  BTFSC  03.2
0423:  GOTO   428
0424:  INCF   34,F
0425:  MOVWF  44
0426:  CALL   1DE
0427:  GOTO   41F
....................          temp_code=read_combination(2,2,15,2); 
0428:  MOVLW  02
0429:  MOVWF  34
042A:  MOVWF  35
042B:  MOVLW  0F
042C:  MOVWF  36
042D:  MOVLW  02
042E:  MOVWF  37
042F:  CALL   2A7
0430:  MOVF   79,W
0431:  MOVWF  33
0432:  MOVF   78,W
0433:  MOVWF  32
....................          write_to_EEPROM(0x00,code_public); 
0434:  CLRF   34
0435:  MOVF   21,W
0436:  MOVWF  36
0437:  MOVF   20,W
0438:  MOVWF  35
0439:  CALL   363
....................       } 
....................    } 
043A:  BCF    0A.3
043B:  BCF    0A.4
043C:  GOTO   60B (RETURN)
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F79   XT NOWDT NOPUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG

ROM data:
002100: 0004 0003 0002 0001 

002120: 0009 0008 0007 0006 
